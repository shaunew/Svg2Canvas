(function (n, t, i) {
    function s(n) {
        var e = !1,
            u, o, i, t, s, f, h, r;
        for (this.ok = !1, n = n.replace(/ /g, "").toLowerCase(), n.charAt(0) == "#" ? n = n.substr(1, 6) : n.substr(0, 3) != "rgb" && (e = !0), e && (o = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "00ffff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000000",
            blanchedalmond: "ffebcd",
            blue: "0000ff",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "00ffff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dodgerblue: "1e90ff",
            feldspar: "d19275",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "ff00ff",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgrey: "d3d3d3",
            lightgreen: "90ee90",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslateblue: "8470ff",
            lightslategray: "778899",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "00ff00",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "ff00ff",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370d8",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "d87093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            red: "ff0000",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            violetred: "d02090",
            wheat: "f5deb3",
            white: "ffffff",
            whitesmoke: "f5f5f5",
            yellow: "ffff00",
            yellowgreen: "9acd32"
        }, u = o[n], typeof u != "undefined" && (n = u)), i = [{
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
            process: function (n) {
                return [parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10)]
            }
        }, {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ["#00ff00", "336699"],
            process: function (n) {
                return [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)]
            }
        }, {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ["#fb0", "f0f"],
            process: function (n) {
                return [parseInt(n[1] + n[1], 16), parseInt(n[2] + n[2], 16), parseInt(n[3] + n[3], 16)]
            }
        }], t = 0; t < i.length; t++)
            if (s = i[t].re, f = s.exec(n), f) {
                h = i[t].process, r = h(f), this.r = r[0], this.g = r[1], this.b = r[2], this.ok = !0;
                break
            }
        this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b
    }

    function v() {
        var t = {};
        return t.FRAMERATE = 1, t.MAX_VIRTUAL_PIXELS = 3e4, t.init = function (n) {
            var i = 0;
            t.UniqueId = function () {
                return i++, "canvg" + i
            }, t.Definitions = {}, t.Styles = {}, t.Animations = [], t.Images = [], t.ctx = n, t.ViewPort = new function () {
                this.viewPorts = [], this.Clear = function () {
                    this.viewPorts = []
                }, this.SetCurrent = function (n, i) {
                    n <= 0 && (n = t.ctx.canvas.width), i <= 0 && (i = t.ctx.canvas.height), this.viewPorts.push({
                        width: n,
                        height: i
                    })
                }, this.RemoveCurrent = function () {
                    this.viewPorts.pop()
                }, this.Current = function () {
                    return this.viewPorts[this.viewPorts.length - 1]
                }, this.width = function () {
                    return this.Current().width
                }, this.height = function () {
                    return this.Current().height
                }, this.ComputeSize = function (n) {
                    return n != null && typeof n == "number" ? n : n == "x" ? this.width() : n == "y" ? this.height() : Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2)
                }
            }
        }, t.init(), t.ImagesLoaded = function () {
            for (var n = t.Images, i = n.length; i--;)
                if (!n[i].loaded) return !1;
            return t.ImagesLoaded = function () {
                return !0
            }, !0
        }, t.trim = function (n) {
            return n.length ? n.replace(/^\s+|\s+$/g, "") : ""
        }, t.compressSpaces = function (n) {
            return n.length ? n.replace(/[\s\r\t\n]+/gm, " ") : ""
        }, t.ajax = function (n) {
            var t;
            if (t = window.XMLHttpRequest ? new XMLHttpRequest : new ActiveXObject("Microsoft.XMLHTTP"), t) try {
                return t.open("GET", n, !1), t.send(null), t.responseText
            } finally {
                t = null
            }
            return null
        }, t.parseXml = function (n) {
            var i, t;
            return window.DOMParser ? (n = n.replace(/<svg /, "<canvg "), n = n.replace(/<\/svg>/, "<\/canvg>"), n = n.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/, 'xmlns="http://www.canvg.org/2000/canvg"'), i = new DOMParser, i.parseFromString(n, "text/xml")) : (n = n.replace(/<!DOCTYPE svg[^>]*>/, ""), t = new ActiveXObject("Microsoft.XMLDOM"), t.async = "false", t.loadXML(n), t)
        }, t.Property = function (n, t) {
            this.name = n, this.value = t
        }, t.Property.prototype.getValue = function () {
            return this.value
        }, t.Property.prototype.hasValue = function () {
            return this.value != null && this.value !== ""
        }, t.Property.prototype.numValue = function () {
            if (!this.hasValue()) return 0;
            var n = parseFloat(this.value);
            return (this.value + "").match(/%$/) && (n = n / 100), n
        }, t.Property.prototype.valueOrDefault = function (n) {
            return this.hasValue() ? this.value : n
        }, t.Property.prototype.numValueOrDefault = function (n) {
            return this.hasValue() ? this.numValue() : n
        }, t.Property.prototype.addOpacity = function (n) {
            var r = this.value,
                i;
            return n != null && n != "" && typeof this.value == "string" && (i = new s(this.value), i.ok && (r = "rgba(" + i.r + "," + i.g + "," + i.b + "," + n + ")"), i = null), new t.Property(this.name, r)
        }, t.Property.prototype.getDefinition = function () {
            var n = this.value.replace(/["']/g, "").match(/#([^\)']+)/);
            return n && (n = n[1]), n || (n = this.value), t.Definitions[n]
        }, t.Property.prototype.isUrlDefinition = function () {
            return this.value.indexOf("url(") == 0
        }, t.Property.prototype.getFillStyleDefinition = function (n, i) {
            var u, r = this.getDefinition();
            if (r != null) try {
                if (r.createGradient ? u = r.createGradient(t.ctx, n, i) : r.createPattern && (u = r.createPattern(t.ctx, n)), u) return u
            } finally {
                u = r = null
            }
            return null
        }, t.Property.prototype.getDPI = function () {
            return 96
        }, t.Property.prototype.getEM = function (n) {
            var r = 12,
                i = new t.Property("fontSize", t.Font.Parse(t.ctx.font).fontSize);
            return i.hasValue() && (r = i.toPixels(n)), i = null, r
        }, t.Property.prototype.getUnits = function () {
            var n = this.value + "";
            return n.replace(/[0-9\.\-]/g, "")
        }, t.Property.prototype.toPixels = function (n, i) {
            var r, u;
            return this.hasValue() ? (r = this.value + "", r.match(/em$/)) ? this.numValue() * this.getEM(n) : r.match(/ex$/) ? this.numValue() * this.getEM(n) / 2 : r.match(/px$/) ? this.numValue() : r.match(/pt$/) ? this.numValue() * this.getDPI(n) * (1 / 72) : r.match(/pc$/) ? this.numValue() * 15 : r.match(/cm$/) ? this.numValue() * this.getDPI(n) / 2.54 : r.match(/mm$/) ? this.numValue() * this.getDPI(n) / 25.4 : r.match(/in$/) ? this.numValue() * this.getDPI(n) : r.match(/%$/) ? this.numValue() * t.ViewPort.ComputeSize(n) : (u = this.numValue(), i && u < 1) ? u * t.ViewPort.ComputeSize(n) : u : 0
        }, t.Property.prototype.toMilliseconds = function () {
            if (!this.hasValue()) return 0;
            var n = this.value + "";
            return n.match(/s$/) ? this.numValue() * 1e3 : (n.match(/ms$/), this.numValue())
        }, t.Property.prototype.toRadians = function () {
            if (!this.hasValue()) return 0;
            var n = this.value + "";
            return n.match(/deg$/) ? this.numValue() * (Math.PI / 180) : n.match(/grad$/) ? this.numValue() * (Math.PI / 200) : n.match(/rad$/) ? this.numValue() : this.numValue() * (Math.PI / 180)
        }, t.Font = new function () {
            this.Styles = "normal|italic|oblique|inherit", this.Variants = "normal|small-caps|inherit", this.Weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit", this.CreateFont = function (i, r, u, f, e, o) {
                var s = o != null ? this.Parse(o) : this.CreateFont("", "", "", "", "", t.ctx.font);
                return {
                    fontFamily: e || s.fontFamily,
                    fontSize: f || s.fontSize,
                    fontStyle: i || s.fontStyle,
                    fontWeight: u || s.fontWeight,
                    fontVariant: r || s.fontVariant,
                    toString: function () {
                        return n.trim([this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(" "))
                    }
                }
            };
            var i = this;
            this.Parse = function (n) {
                for (var e = {}, u = t.trim(t.compressSpaces(n || "")).split(" "), f = {
                        fontSize: !1,
                        fontStyle: !1,
                        fontWeight: !1,
                        fontVariant: !1
                    }, o = "", r = 0; r < u.length; r++) f.fontStyle || i.Styles.indexOf(u[r]) == -1 ? f.fontVariant || i.Variants.indexOf(u[r]) == -1 ? f.fontWeight || i.Weights.indexOf(u[r]) == -1 ? f.fontSize ? u[r] != "inherit" && (o += u[r]) : (u[r] != "inherit" && (e.fontSize = u[r].split("/")[0]), f.fontStyle = f.fontVariant = f.fontWeight = f.fontSize = !0) : (u[r] != "inherit" && (e.fontWeight = u[r]), f.fontStyle = f.fontVariant = f.fontWeight = !0) : (u[r] != "inherit" && (e.fontVariant = u[r]), f.fontStyle = f.fontVariant = !0) : (u[r] != "inherit" && (e.fontStyle = u[r]), f.fontStyle = !0);
                return o != "" && (e.fontFamily = o), e
            }
        }, t.ToNumberArray = function (n) {
            for (var r = t.trim(t.compressSpaces((n || "").replace(/,/g, " "))).split(" "), i = 0; i < r.length; i++) r[i] = parseFloat(r[i]);
            return r
        }, t.Point = function (n, t) {
            this.x = n, this.y = t
        }, t.Point.prototype.angleTo = function (n) {
            return Math.atan2(n.y - this.y, n.x - this.x)
        }, t.Point.prototype.applyTransform = function (n) {
            var t = this.x * n[0] + this.y * n[2] + n[4],
                i = this.x * n[1] + this.y * n[3] + n[5];
            this.x = t, this.y = i
        }, t.CreatePoint = function (n) {
            var i = t.ToNumberArray(n);
            return new t.Point(i[0], i[1])
        }, t.CreatePath = function (n) {
            for (var r = t.ToNumberArray(n), u = [], i = 0; i < r.length; i += 2) u.push(new t.Point(r[i], r[i + 1]));
            return u
        }, t.BoundingBox = function (n, t, i, r) {
            this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN, this.x = function () {
                return this.x1
            }, this.y = function () {
                return this.y1
            }, this.width = function () {
                return this.x2 - this.x1
            }, this.height = function () {
                return this.y2 - this.y1
            }, this.addPoint = function (n, t) {
                n != null && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = n, this.x2 = n), n < this.x1 && (this.x1 = n), n > this.x2 && (this.x2 = n)), t != null && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t))
            }, this.addX = function (n) {
                this.addPoint(n, null)
            }, this.addY = function (n) {
                this.addPoint(null, n)
            }, this.addBoundingBox = function (n) {
                this.addPoint(n.x1, n.y1), this.addPoint(n.x2, n.y2)
            }, this.addQuadraticCurve = function (n, t, i, r, u, f) {
                var e = n + 2 / 3 * (i - n),
                    o = t + 2 / 3 * (r - t),
                    s = e + 1 / 3 * (u - n),
                    h = o + 1 / 3 * (f - t);
                this.addBezierCurve(n, t, e, s, o, h, u, f)
            }, this.addBezierCurve = function (n, t, i, r, u, f, e, o) {
                var h = [n, t],
                    p = [i, r],
                    d = [u, f],
                    w = [e, o],
                    s, a, k, v, y;
                for (this.addPoint(h[0], h[1]), this.addPoint(w[0], w[1]), s = 0; s <= 1; s++) {
                    var c = function (n) {
                        return Math.pow(1 - n, 3) * h[s] + 3 * Math.pow(1 - n, 2) * n * p[s] + 3 * (1 - n) * Math.pow(n, 2) * d[s] + Math.pow(n, 3) * w[s]
                    }, l = 6 * h[s] - 12 * p[s] + 6 * d[s],
                        b = -3 * h[s] + 9 * p[s] - 9 * d[s] + 3 * w[s],
                        g = 3 * p[s] - 3 * h[s];
                    if (b == 0) {
                        if (l == 0) continue;
                        a = -g / l, 0 < a && a < 1 && (s == 0 && this.addX(c(a)), s == 1 && this.addY(c(a)));
                        continue
                    }(k = Math.pow(l, 2) - 4 * g * b, k < 0) || (v = (-l + Math.sqrt(k)) / (2 * b), 0 < v && v < 1 && (s == 0 && this.addX(c(v)), s == 1 && this.addY(c(v))), y = (-l - Math.sqrt(k)) / (2 * b), 0 < y && y < 1 && (s == 0 && this.addX(c(y)), s == 1 && this.addY(c(y))))
                }
            }, this.isPointInBox = function (n, t) {
                return this.x1 <= n && n <= this.x2 && this.y1 <= t && t <= this.y2
            }, this.addPoint(n, t), this.addPoint(i, r)
        }, t.Transform = function (n) {
            var u = this,
                r, i;
            for (this.Type = {}, this.Type.translate = function (n) {
                this.p = t.CreatePoint(n), this.apply = function (n) {
                    var i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Transform.translate").translate(this.p.x || 0, this.p.y || 0);
                    i = null
                }, this.applyToPoint = function (n) {
                    n.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0])
                }
            }, this.Type.rotate = function (n) {
                var i = t.ToNumberArray(n);
                this.angle = new t.Property("angle", i[0]), this.cx = i[1] || 0, this.cy = i[2] || 0, this.apply = function (n) {
                    var i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Transform.rotate start").translate(this.cx, this.cy).rotate(this.angle.toRadians()).translate(-this.cx, -this.cy).logComment("svg.Transform.rotate end");
                    i = null
                }, this.applyToPoint = function (n) {
                    var t = this.angle.toRadians();
                    n.applyTransform([1, 0, 0, 1, this.p.x || 0, this.p.y || 0]), n.applyTransform([Math.cos(t), Math.sin(t), -Math.sin(t), Math.cos(t), 0, 0]), n.applyTransform([1, 0, 0, 1, -this.p.x || 0, -this.p.y || 0])
                }
            }, this.Type.scale = function (n) {
                this.p = t.CreatePoint(n), this.apply = function (n) {
                    var i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Transform.scale").scale(this.p.x || 1, this.p.y || this.p.x || 1);
                    i = null
                }, this.applyToPoint = function (n) {
                    n.applyTransform([this.p.x || 0, 0, 0, this.p.y || 0, 0, 0])
                }
            }, this.Type.matrix = function (n) {
                this.m = t.ToNumberArray(n), this.apply = function (n) {
                    var i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Transform.matrix").transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                    i = null
                }, this.applyToPoint = function (n) {
                    n.applyTransform(this.m)
                }
            }, this.Type.SkewBase = function (n) {
                this.base = u.Type.matrix, this.base(n), this.angle = new t.Property("angle", n)
            }, this.Type.SkewBase.prototype = new this.Type.matrix, this.Type.skewX = function (n) {
                this.base = u.Type.SkewBase, this.base(n), this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0]
            }, this.Type.skewX.prototype = new this.Type.SkewBase, this.Type.skewY = function (n) {
                this.base = u.Type.SkewBase, this.base(n), this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0]
            }, this.Type.skewY.prototype = new this.Type.SkewBase, this.transforms = [], this.apply = function (n) {
                for (var i = this.transforms.length, t = 0; t < i; t++) this.transforms[t].apply(n)
            }, this.applyToPoint = function (n) {
                for (var i = this.transforms.length, t = 0; t < i; t++) this.transforms[t].applyToPoint(n)
            }, r = t.trim(t.compressSpaces(n)).replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/), i = 0; i < r.length; i++) {
                var f = t.trim(r[i].split("(")[0]),
                    o = r[i].split("(")[1].replace(")", ""),
                    e = new this.Type[f](o);
                e.type = f, this.transforms.push(e)
            }
        }, t.Transform.prototype.destroy = function () {
            var n, i, t;
            for (this.Type = null, n = this.transforms, i = n.length, t = 0; t < i; t++) n[t] = null;
            n.length = 0
        }, t.AspectRatio = function (n, i, r, u, f, e, o, s, h, c) {
            var l = t.opts.cbGetOSS2DCTX(n).logComment("svg.AspectRatio start");
            i = t.compressSpaces(i), i = i.replace(/^defer\s/, "");
            var b = i.split(" ")[0] || "xMidYMid",
                a = i.split(" ")[1] || "meet",
                p = r / u,
                w = f / e,
                v = Math.min(p, w),
                y = Math.max(p, w);
            a == "meet" && (u *= v, e *= v), a == "slice" && (u *= y, e *= y), h = new t.Property("refX", h), c = new t.Property("refY", c), h.hasValue() && c.hasValue() ? l.translate(-v * h.toPixels("x"), -v * c.toPixels("y")) : (l.logComment("svg.AspectRatio.align start"), b.match(/^xMid/) && (a == "meet" && v == w || a == "slice" && y == w) && l.translate(r / 2 - u / 2, 0), b.match(/YMid$/) && (a == "meet" && v == p || a == "slice" && y == p) && l.translate(0, f / 2 - e / 2), b.match(/^xMax/) && (a == "meet" && v == w || a == "slice" && y == w) && l.translate(r - u, 0), b.match(/YMax$/) && (a == "meet" && v == p || a == "slice" && y == p) && l.translate(0, f - e), l.logComment("svg.AspectRatio.align end")), l.logComment("svg.AspectRatio.scale start"), b == "none" ? l.scale(p, w) : a == "meet" ? l.scale(v, v) : a == "slice" && l.scale(y, y), l.logComment("svg.AspectRatio.scale end"), l.translate(o == null ? 0 : -o, s == null ? 0 : -s).logComment("svg.AspectRatio end"), l = null
        }, t.Element = {}, t.EmptyProperty = new t.Property("EMPTY", ""), t.Element.ElementBase = function (n) {
            var f, o, s, e, u, i, r;
            if (this.attributes = {}, this.styles = {}, this.children = [], this.attribute = function (n, i) {
                var r = this.attributes[n];
                return r != null ? r : (i == !0 && (r = new t.Property(n, ""), this.attributes[n] = r), r || t.EmptyProperty)
            }, this.getHrefAttribute = function () {
                for (var n in this.attributes)
                    if (n.match(/:href$/)) return this.attributes[n];
                return t.EmptyProperty
            }, this.style = function (n, i) {
                var r = this.styles[n],
                    u, e, f;
                return r != null ? r : (u = this.attribute(n), u != null && u.hasValue()) ? (this.styles[n] = u, u) : (e = this.parent, e != null && (f = e.style(n), f != null && f.hasValue())) ? f : (i == !0 && (r = new t.Property(n, ""), this.styles[n] = r), r || t.EmptyProperty)
            }, this.render = function (n) {
                var i, r, u;
                this.style("display").value != "none" && this.attribute("visibility").value != "hidden" && (i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.ElementBase.render Start").save(), this.attribute("mask").hasValue() ? (r = this.attribute("mask").getDefinition(), r != null && r.apply(n, this)) : this.style("filter").hasValue() ? (u = this.style("filter").getDefinition(), u != null && u.apply(n, this)) : (this.setContext(n), this.renderChildren(n), this.clearContext(n)), i.restore().logComment("svg.Element.ElementBase.render End"), i = null)
            }, this.setContext = function () {}, this.clearContext = function () {}, this.renderChildren = function (n) {
                for (var t = 0; t < this.children.length; t++) this.children[t].render(n)
            }, this.addChild = function (n, i) {
                var r = n;
                i && (r = t.CreateElement(n)), r.parent = this, this.children.push(r), r = null
            }, n != null && n.nodeType == 1) {
                for (r = 0; r < n.childNodes.length; r++) f = n.childNodes[r], f.nodeType == 1 && this.addChild(f, !0), this.captureTextNodes && f.nodeType == 3 && this.addChild(new t.Element.tspan(f), !1);
                for (r = 0; r < n.attributes.length; r++) o = n.attributes[r], this.attributes[o.nodeName] = new t.Property(o.nodeName, o.nodeValue);
                if (i = t.Styles[n.nodeName], i != null)
                    for (u in i) this.styles[u] = i[u];
                if (this.attribute("class").hasValue())
                    for (s = t.compressSpaces(this.attribute("class").value).split(" "), e = 0; e < s.length; e++) {
                        if (i = t.Styles["." + s[e]], i != null)
                            for (u in i) this.styles[u] = i[u];
                        if (i = t.Styles[n.nodeName + "." + s[e]], i != null)
                            for (u in i) this.styles[u] = i[u]
                    }
                if (this.attribute("id").hasValue() && (i = t.Styles["#" + this.attribute("id").value], i != null))
                    for (u in i) this.styles[u] = i[u];
                if (this.attribute("style").hasValue())
                    for (i = this.attribute("style").value.split(";"), r = 0; r < i.length; r++)
                        if (t.trim(i[r]) != "") {
                            var h = i[r].split(":"),
                                u = t.trim(h[0]),
                                c = t.trim(h[1]);
                            this.styles[u] = new t.Property(u, c)
                        }
                this.attribute("id").hasValue() && t.Definitions[this.attribute("id").value] == null && (t.Definitions[this.attribute("id").value] = this)
            }
        }, t.Element.RenderedElementBase = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.setContext = function (n) {
                var f = null,
                    i, r, u = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.RenderedElementBase.fill start"),
                    e;
                i = this.style("fill"), i.isUrlDefinition() ? f = i.getFillStyleDefinition(this, this.style("fill-opacity")) : i.hasValue() && (i.value == "currentColor" && (i.value = this.style("color").value), f = i.value == "none" ? "rgba(0,0,0,0)" : i.value), r = this.style("fill-opacity"), r.hasValue() && typeof n.fillStyle != "object" && (i = new t.Property("fill", f == null ? n.fillStyle : f), i = i.addOpacity(r.value), f = i.value), r = null, f != null && (u.fillStyle(f), f = null), u.logComment("svg.Element.RenderedElementBase.fill end").logComment("svg.Element.RenderedElementBase.stroke start"), i = this.style("stroke"), i.isUrlDefinition() ? (f = i.getFillStyleDefinition(this, this.style("stroke-opacity")), f != null && u.strokeStyle(f)) : i.hasValue() && (i.value == "currentColor" && (i.value = this.style("color").value), u.strokeStyle(i.value == "none" ? "rgba(0,0,0,0)" : i.value)), i = this.style("stroke-opacity"), i.hasValue() && typeof n.strokeStyle != "object" && (r = new t.Property("stroke", n.strokeStyle), r = r.addOpacity(i.value), u.strokeStyle(r.value)), i = this.style("stroke-width"), i.hasValue() && (e = i.toPixels(), u.lineWidth(e == 0 ? .001 : e)), i = this.style("stroke-linecap"), i.hasValue() && u.lineCap(i.value), i = this.style("stroke-linejoin"), i.hasValue() && u.lineJoin(i.value), i = this.style("stroke-miterlimit"), i.hasValue() && u.miterLimit(i.value), u.logComment("svg.Element.RenderedElementBase.stroke end"), typeof n.font != "undefined" && u.logComment("svg.Element.RenderedElementBase.font").font(t.Font.CreateFont(this.style("font-style").value, this.style("font-variant").value, this.style("font-weight").value, this.style("font-size").hasValue() ? this.style("font-size").toPixels() + "px" : "", this.style("font-family").value).toString()), this.attribute("transform").hasValue() && (u.logComment("svg.Element.RenderedElementBase.transform"), r = new t.Transform(this.attribute("transform").value), r.apply(n), r.destroy()), this.attribute("clip-path").hasValue() && (u.logComment("svg.Element.RenderedElementBase.clip"), r = this.attribute("clip-path").getDefinition(), r != null && r.apply(n)), this.style("opacity").hasValue() && (u.logComment("svg.Element.RenderedElementBase.opacity").globalAlpha = this.style("opacity").numValue()), i = r = u = f = null
            }
        }, t.Element.RenderedElementBase.prototype = new t.Element.ElementBase, t.Element.PathElementBase = function (n) {
            this.base = t.Element.RenderedElementBase, this.base(n), this.path = function (n) {
                if (n != null) {
                    var i = t.opts.cbGetOSS2DCTX(n).beginPath();
                    i = null
                }
                return new t.BoundingBox
            }, this.renderChildren = function (n) {
                var f = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.PathElementBase.renderChildren start"),
                    i, u, r;
                if (this.path(n), t.Mouse.checkPath(this, n), n.fillStyle != "" && f.fill(), n.strokeStyle != "" && f.stroke(), i = this.getMarkers(), i != null) {
                    if (this.style("marker-start").isUrlDefinition() && (r = this.style("marker-start").getDefinition(), r.render(n, i[0][0], i[0][1])), this.style("marker-mid").isUrlDefinition())
                        for (r = this.style("marker-mid").getDefinition(), u = 1; u < i.length - 1; u++) r.render(n, i[u][0], i[u][1]);
                    this.style("marker-end").isUrlDefinition() && (r = this.style("marker-end").getDefinition(), r.render(n, i[i.length - 1][0], i[i.length - 1][1]))
                }
                f.logComment("svg.Element.PathElementBase.renderChildren end"), f = null
            }, this.getBoundingBox = function () {
                return this.path()
            }, this.getMarkers = function () {
                return null
            }
        }, t.Element.PathElementBase.prototype = new t.Element.RenderedElementBase, t.Element.svg = function (n) {
            this.base = t.Element.RenderedElementBase, this.base(n), this.baseClearContext = this.clearContext, this.clearContext = function (n) {
                this.baseClearContext(n), t.ViewPort.RemoveCurrent()
            }, this.baseSetContext = this.setContext, this.setContext = function (n) {
                var f = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.svg start").strokeStyle("rgba(0,0,0,0)").lineCap("butt").lineJoin("miter").miterLimit(4),
                    i, r, e, o;
                if (this.baseSetContext(n), this.attribute("x").hasValue() || (this.attribute("x", !0).value = 0), this.attribute("y").hasValue() || (this.attribute("y", !0).value = 0), f.translate(this.attribute("x").toPixels("x"), this.attribute("y").toPixels("y")), i = t.ViewPort.width(), r = t.ViewPort.height(), this.attribute("width").hasValue() || (this.attribute("width", !0).value = "100%"), this.attribute("height").hasValue() || (this.attribute("height", !0).value = "100%"), typeof this.root == "undefined" && (i = this.attribute("width").toPixels("x"), r = this.attribute("height").toPixels("y"), e = 0, o = 0, this.attribute("refX").hasValue() && this.attribute("refY").hasValue() && (e = -this.attribute("refX").toPixels("x"), o = -this.attribute("refY").toPixels("y")), f.beginPath().moveTo(e, o).lineTo(i, o).lineTo(i, r).lineTo(e, r).closePath().clip()), t.ViewPort.SetCurrent(i, r), this.attribute("viewBox").hasValue()) {
                    var u = t.ToNumberArray(this.attribute("viewBox").value),
                        s = u[0],
                        h = u[1];
                    i = u[2], r = u[3], t.AspectRatio(n, this.attribute("preserveAspectRatio").value, t.ViewPort.width(), i, t.ViewPort.height(), r, s, h, this.attribute("refX").value, this.attribute("refY").value), t.ViewPort.RemoveCurrent(), t.ViewPort.SetCurrent(u[2], u[3])
                }
                f.logComment("svg.Element.svg end"), f = null
            }
        }, t.Element.svg.prototype = new t.Element.RenderedElementBase, t.Element.rect = function (n) {
            this.base = t.Element.PathElementBase, this.base(n), this.path = function (n) {
                var i = this.attribute("x").toPixels("x"),
                    r = this.attribute("y").toPixels("y"),
                    f = this.attribute("width").toPixels("x"),
                    e = this.attribute("height").toPixels("y"),
                    u = this.attribute("rx").toPixels("x"),
                    o = this.attribute("ry").toPixels("y"),
                    s;
                return this.attribute("rx").hasValue() && !this.attribute("ry").hasValue() && (o = u), this.attribute("ry").hasValue() && !this.attribute("rx").hasValue() && (u = o), u = Math.min(u, f / 2), o = Math.min(o, e / 2), n != null && (s = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.rect.path start").beginPath().moveTo(i + u, r).lineTo(i + f - u, r).quadraticCurveTo(i + f, r, i + f, r + o).lineTo(i + f, r + e - o).quadraticCurveTo(i + f, r + e, i + f - u, r + e).lineTo(i + u, r + e).quadraticCurveTo(i, r + e, i, r + e - o).lineTo(i, r + o).quadraticCurveTo(i, r, i + u, r).closePath().logComment("svg.Element.rect.path end"), s = null), new t.BoundingBox(i, r, i + f, r + e)
            }
        }, t.Element.rect.prototype = new t.Element.PathElementBase, t.Element.circle = function (n) {
            this.base = t.Element.PathElementBase, this.base(n), this.path = function (n) {
                var r = this.attribute("cx").toPixels("x"),
                    u = this.attribute("cy").toPixels("y"),
                    i = this.attribute("r").toPixels(),
                    f;
                return n != null && (f = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.circle start").beginPath().arc(r, u, i, 0, Math.PI * 2, !0).closePath().logComment("svg.Element.circle end"), f = null), new t.BoundingBox(r - i, u - i, r + i, u + i)
            }
        }, t.Element.circle.prototype = new t.Element.PathElementBase, t.Element.ellipse = function (n) {
            this.base = t.Element.PathElementBase, this.base(n), this.path = function (n) {
                var e = 4 * ((Math.sqrt(2) - 1) / 3),
                    f = this.attribute("rx").toPixels("x"),
                    u = this.attribute("ry").toPixels("y"),
                    i = this.attribute("cx").toPixels("x"),
                    r = this.attribute("cy").toPixels("y"),
                    o;
                return n != null && (o = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.ellipse.path start").beginPath().moveTo(i, r - u).bezierCurveTo(i + e * f, r - u, i + f, r - e * u, i + f, r).bezierCurveTo(i + f, r + e * u, i + e * f, r + u, i, r + u).bezierCurveTo(i - e * f, r + u, i - f, r + e * u, i - f, r).bezierCurveTo(i - f, r - e * u, i - e * f, r - u, i, r - u).closePath().logComment("svg.Element.ellipse.path end"), o = null), new t.BoundingBox(i - f, r - u, i + f, r + u)
            }
        }, t.Element.ellipse.prototype = new t.Element.PathElementBase, t.Element.line = function (n) {
            this.base = t.Element.PathElementBase, this.base(n), this.getPoints = function () {
                return [new t.Point(this.attribute("x1").toPixels("x"), this.attribute("y1").toPixels("y")), new t.Point(this.attribute("x2").toPixels("x"), this.attribute("y2").toPixels("y"))]
            }, this.path = function (n) {
                var i = this.getPoints(),
                    r;
                return n != null && (r = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.line.path start").beginPath().moveTo(i[0].x, i[0].y).lineTo(i[1].x, i[1].y).logComment("svg.Element.line.path end"), r = null), new t.BoundingBox(i[0].x, i[0].y, i[1].x, i[1].y)
            }, this.getMarkers = function () {
                var n = this.getPoints(),
                    t = n[0].angleTo(n[1]);
                return [[n[0], t], [n[1], t]]
            }
        }, t.Element.line.prototype = new t.Element.PathElementBase, t.Element.polyline = function (n) {
            this.base = t.Element.PathElementBase, this.base(n), this.points = t.CreatePath(this.attribute("points").value), this.path = function (n) {
                var u = new t.BoundingBox(this.points[0].x, this.points[0].y),
                    r, i;
                for (n != null && (r = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.polyline.path start").beginPath().moveTo(this.points[0].x, this.points[0].y)), i = 1; i < this.points.length; i++) u.addPoint(this.points[i].x, this.points[i].y), n != null && r.lineTo(this.points[i].x, this.points[i].y).logComment("svg.Element.polyline.path end");
                return r = null, u
            }, this.getMarkers = function () {
                for (var t = [], n = 0; n < this.points.length - 1; n++) t.push([this.points[n], this.points[n].angleTo(this.points[n + 1])]);
                return t.push([this.points[this.points.length - 1], t[t.length - 1][1]]), t
            }
        }, t.Element.polyline.prototype = new t.Element.PathElementBase, t.Element.polygon = function (n) {
            this.base = t.Element.polyline, this.base(n), this.basePath = this.path, this.path = function (n) {
                var r = this.basePath(n),
                    i;
                return n != null && (i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.polygon.path start").lineTo(this.points[0].x, this.points[0].y).closePath().logComment("svg.Element.polygon.path end"), i = null), r
            }
        }, t.Element.polygon.prototype = new t.Element.polyline, t.Element.path = function (n) {
            this.base = t.Element.PathElementBase, this.base(n);
            var i = this.attribute("d").value;
            i = i.replace(/,/gm, " "), i = i.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), i = i.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), i = i.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2"), i = i.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), i = i.replace(/([0-9])([+\-])/gm, "$1 $2"), i = i.replace(/(\.[0-9]*)(\.)/gm, "$1 $2"), i = i.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "), i = t.compressSpaces(i), i = t.trim(i), this.PathParser = new function (n) {
                this.tokens = n.split(" "), this.reset = function () {
                    this.i = -1, this.command = "", this.previousCommand = "", this.start = new t.Point(0, 0), this.control = new t.Point(0, 0), this.current = new t.Point(0, 0), this.points = [], this.angles = []
                }, this.isEnd = function () {
                    return this.i >= this.tokens.length - 1
                }, this.isCommandOrEnd = function () {
                    return this.isEnd() ? !0 : this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null
                }, this.isRelativeCommand = function () {
                    switch (this.command) {
                    case "m":
                    case "l":
                    case "h":
                    case "v":
                    case "c":
                    case "s":
                    case "q":
                    case "t":
                    case "a":
                    case "z":
                        return !0
                    }
                    return !1
                }, this.getToken = function () {
                    return this.i++, this.tokens[this.i]
                }, this.getScalar = function () {
                    return parseFloat(this.getToken())
                }, this.nextCommand = function () {
                    this.previousCommand = this.command, this.command = this.getToken()
                }, this.getPoint = function () {
                    var n = new t.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(n)
                }, this.getAsControlPoint = function () {
                    var n = this.getPoint();
                    return this.control = n, n
                }, this.getAsCurrentPoint = function () {
                    var n = this.getPoint();
                    return this.current = n, n
                }, this.getReflectedControlPoint = function () {
                    if (this.previousCommand.toLowerCase() != "c" && this.previousCommand.toLowerCase() != "s" && this.previousCommand.toLowerCase() != "q" && this.previousCommand.toLowerCase() != "t") return this.current;
                    return new t.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y)
                }, this.makeAbsolute = function (n) {
                    return this.isRelativeCommand() && (n.x += this.current.x, n.y += this.current.y), n
                }, this.addMarker = function (n, t, i) {
                    i != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(i)), this.addMarkerAngle(n, t == null ? null : t.angleTo(n))
                }, this.addMarkerAngle = function (n, t) {
                    this.points.push(n), this.angles.push(t)
                }, this.getMarkerPoints = function () {
                    return this.points
                }, this.getMarkerAngles = function () {
                    for (var t, n = 0; n < this.angles.length; n++)
                        if (this.angles[n] == null)
                            for (t = n + 1; t < this.angles.length; t++)
                                if (this.angles[t] != null) {
                                    this.angles[n] = this.angles[t];
                                    break
                                }
                    return this.angles
                }
            }(i), this.path = function (n) {
                var i = this.PathParser,
                    l, h, et, f, p, e, u, r, b;
                for (i.reset(), l = new t.BoundingBox, n != null && (h = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.path start").beginPath()); !i.isEnd();) {
                    i.nextCommand();
                    switch (i.command) {
                    case "M":
                    case "m":
                        for (f = i.getAsCurrentPoint(), i.addMarker(f), l.addPoint(f.x, f.y), n != null && h.moveTo(f.x, f.y), i.start = i.current; !i.isCommandOrEnd();) f = i.getAsCurrentPoint(), i.addMarker(f, i.start), l.addPoint(f.x, f.y), n != null && h.lineTo(f.x, f.y);
                        break;
                    case "L":
                    case "l":
                        while (!i.isCommandOrEnd()) et = i.current, f = i.getAsCurrentPoint(), i.addMarker(f, et), l.addPoint(f.x, f.y), n != null && h.lineTo(f.x, f.y);
                        break;
                    case "H":
                    case "h":
                        while (!i.isCommandOrEnd()) p = new t.Point((i.isRelativeCommand() ? i.current.x : 0) + i.getScalar(), i.current.y), i.addMarker(p, i.current), i.current = p, l.addPoint(i.current.x, i.current.y), n != null && h.lineTo(i.current.x, i.current.y);
                        break;
                    case "V":
                    case "v":
                        while (!i.isCommandOrEnd()) p = new t.Point(i.current.x, (i.isRelativeCommand() ? i.current.y : 0) + i.getScalar()), i.addMarker(p, i.current), i.current = p, l.addPoint(i.current.x, i.current.y), n != null && h.lineTo(i.current.x, i.current.y);
                        break;
                    case "C":
                    case "c":
                        while (!i.isCommandOrEnd()) {
                            var e = i.current,
                                a = i.getPoint(),
                                u = i.getAsControlPoint(),
                                r = i.getAsCurrentPoint();
                            i.addMarker(r, u, a), l.addBezierCurve(e.x, e.y, a.x, a.y, u.x, u.y, r.x, r.y), n != null && h.bezierCurveTo(a.x, a.y, u.x, u.y, r.x, r.y)
                        }
                        break;
                    case "S":
                    case "s":
                        while (!i.isCommandOrEnd()) {
                            var e = i.current,
                                a = i.getReflectedControlPoint(),
                                u = i.getAsControlPoint(),
                                r = i.getAsCurrentPoint();
                            i.addMarker(r, u, a), l.addBezierCurve(e.x, e.y, a.x, a.y, u.x, u.y, r.x, r.y), n != null && h.bezierCurveTo(a.x, a.y, u.x, u.y, r.x, r.y)
                        }
                        break;
                    case "Q":
                    case "q":
                        while (!i.isCommandOrEnd()) {
                            var e = i.current,
                                u = i.getAsControlPoint(),
                                r = i.getAsCurrentPoint();
                            i.addMarker(r, u, u), l.addQuadraticCurve(e.x, e.y, u.x, u.y, r.x, r.y), n != null && h.quadraticCurveTo(u.x, u.y, r.x, r.y)
                        }
                        break;
                    case "T":
                    case "t":
                        while (!i.isCommandOrEnd()) e = i.current, u = i.getReflectedControlPoint(), i.control = u, r = i.getAsCurrentPoint(), i.addMarker(r, u, u), l.addQuadraticCurve(e.x, e.y, u.x, u.y, r.x, r.y), n != null && h.quadraticCurveTo(u.x, u.y, r.x, r.y);
                        break;
                    case "A":
                    case "a":
                        while (!i.isCommandOrEnd()) {
                            var e = i.current,
                                o = i.getScalar(),
                                s = i.getScalar(),
                                v = i.getScalar() * (Math.PI / 180),
                                lt = i.getScalar(),
                                nt = i.getScalar(),
                                r = i.getAsCurrentPoint(),
                                c = new t.Point(Math.cos(v) * (e.x - r.x) / 2 + Math.sin(v) * (e.y - r.y) / 2, -Math.sin(v) * (e.x - r.x) / 2 + Math.cos(v) * (e.y - r.y) / 2),
                                tt = Math.pow(c.x, 2) / Math.pow(o, 2) + Math.pow(c.y, 2) / Math.pow(s, 2);
                            tt > 1 && (o *= Math.sqrt(tt), s *= Math.sqrt(tt)), b = (lt == nt ? -1 : 1) * Math.sqrt((Math.pow(o, 2) * Math.pow(s, 2) - Math.pow(o, 2) * Math.pow(c.y, 2) - Math.pow(s, 2) * Math.pow(c.x, 2)) / (Math.pow(o, 2) * Math.pow(c.y, 2) + Math.pow(s, 2) * Math.pow(c.x, 2))), isNaN(b) && (b = 0);
                            var y = new t.Point(b * o * c.y / s, b * -s * c.x / o),
                                w = new t.Point((e.x + r.x) / 2 + Math.cos(v) * y.x - Math.sin(v) * y.y, (e.y + r.y) / 2 + Math.sin(v) * y.x + Math.cos(v) * y.y),
                                ot = function (n) {
                                    return Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2))
                                }, k = function (n, t) {
                                    return (n[0] * t[0] + n[1] * t[1]) / (ot(n) * ot(t))
                                }, st = function (n, t) {
                                    return (n[0] * t[1] < n[1] * t[0] ? -1 : 1) * Math.acos(k(n, t))
                                }, it = st([1, 0], [(c.x - y.x) / o, (c.y - y.y) / s]),
                                rt = [(c.x - y.x) / o, (c.y - y.y) / s],
                                ut = [(-c.x - y.x) / o, (-c.y - y.y) / s],
                                d = st(rt, ut);
                            k(rt, ut) <= -1 && (d = Math.PI), k(rt, ut) >= 1 && (d = 0);
                            var ft = 1 - nt ? 1 : -1,
                                g = it + ft * (d / 2),
                                at = new t.Point(w.x + o * Math.cos(g), w.y + s * Math.sin(g));
                            if (i.addMarkerAngle(at, g - ft * Math.PI / 2), i.addMarkerAngle(r, g - ft * Math.PI), l.addPoint(r.x, r.y), n != null) {
                                var k = o > s ? o : s,
                                    ht = o > s ? 1 : o / s,
                                    ct = o > s ? s / o : 1;
                                h.translate(w.x, w.y).rotate(v).scale(ht, ct).arc(0, 0, k, it, it + d, 1 - nt).scale(1 / ht, 1 / ct).rotate(-v).translate(-w.x, -w.y)
                            }
                        }
                        break;
                    case "Z":
                    case "z":
                        n != null && h.closePath(), i.current = i.start
                    }
                }
                return n != null && (h.logComment("svg.Element.path end"), h = null), l
            }, this.getMarkers = function () {
                for (var t = this.PathParser.getMarkerPoints(), r = this.PathParser.getMarkerAngles(), i = [], n = 0; n < t.length; n++) i.push([t[n], r[n]]);
                return i
            }
        }, t.Element.path.prototype = new t.Element.PathElementBase, t.Element.pattern = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.createPattern = function (n) {
                var s = this.attribute("width").toPixels("x", !0),
                    h = this.attribute("height").toPixels("y", !0),
                    r = new t.Element.svg,
                    i, u, f, e, o;
                for (r.attributes.viewBox = new t.Property("viewBox", this.attribute("viewBox").value), r.attributes.width = new t.Property("width", s + "px"), r.attributes.height = new t.Property("height", h + "px"), r.attributes.transform = new t.Property("transform", this.attribute("patternTransform").value), r.children = this.children, i = t.opts.cbGetWorkPad(s, h), u = i.getContext("2d"), this.attribute("x").hasValue() && this.attribute("y").hasValue() && u.translate(this.attribute("x").toPixels("x", !0), this.attribute("y").toPixels("y", !0)), f = -1; f <= 1; f++)
                    for (e = -1; e <= 1; e++) u.save(), u.translate(f * i.width, e * i.height), r.render(u), u.restore();
                return o = t.opts.cbGetOSS2DCTX(n).fnPatternStart("zzz", i.width, i.height), r.render(u), o.fnPatternEnd(), i = o.createPattern(i, "repeat"), r = o = u = null, i
            }
        }, t.Element.pattern.prototype = new t.Element.ElementBase, t.Element.marker = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.baseRender = this.render, this.render = function (n, i, r) {
                var f = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.marker begin").translate(i.x, i.y),
                    u;
                this.attribute("orient").valueOrDefault("auto") == "auto" && f.rotate(r), this.attribute("markerUnits").valueOrDefault("strokeWidth") == "strokeWidth" && f.scale(n.lineWidth, n.lineWidth), f.save(), u = new t.Element.svg, u.attributes.viewBox = new t.Property("viewBox", this.attribute("viewBox").value), u.attributes.refX = new t.Property("refX", this.attribute("refX").value), u.attributes.refY = new t.Property("refY", this.attribute("refY").value), u.attributes.width = new t.Property("width", this.attribute("markerWidth").value), u.attributes.height = new t.Property("height", this.attribute("markerHeight").value), u.attributes.fill = new t.Property("fill", this.attribute("fill").valueOrDefault("black")), u.attributes.stroke = new t.Property("stroke", this.attribute("stroke").valueOrDefault("none")), u.children = this.children, u.render(n), f.restore(), this.attribute("markerUnits").valueOrDefault("strokeWidth") == "strokeWidth" && f.scale(1 / n.lineWidth, 1 / n.lineWidth), this.attribute("orient").valueOrDefault("auto") == "auto" && f.rotate(-r), f.translate(-i.x, -i.y).logComment("svg.Element.marker end"), f = null
            }
        }, t.Element.marker.prototype = new t.Element.ElementBase, t.Element.defs = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.render = function () {}
        }, t.Element.defs.prototype = new t.Element.ElementBase, t.Element.GradientBase = function (n) {
            var i, r;
            for (this.base = t.Element.ElementBase, this.base(n), this.gradientUnits = this.attribute("gradientUnits").valueOrDefault("objectBoundingBox"), this.stops = [], i = 0; i < this.children.length; i++) r = this.children[i], r.type == "stop" && this.stops.push(r);
            this.getGradient = function () {}, this.createGradient = function (n, i, r) {
                var a = this,
                    d, b, y, u, s, l, p;
                this.getHrefAttribute().hasValue() && (a = this.getHrefAttribute().getDefinition());
                var g = function (n) {
                    if (r.hasValue()) {
                        var i = new t.Property("color", n);
                        return i.addOpacity(r.value).value
                    }
                    return n
                }, h = this.getGradient(n, i),
                    k, w, nt = a.stops.length;
                if (h == null) return g(a.stops[a.stops.length - 1].color);
                for (k = this.attribute("gradientTransform").hasValue(), b = 0; b < nt; b++) w = a.stops[b], d = g(w.color), k || (h[f] += ";\n_gm.addColorStop(" + w.offset + ",'" + d + "')"), h.addColorStop(w.offset, d);
                if (k) {
                    var tt = t.opts.cbGetOSS2DCTX(n).logComment(e + "\nGradientTransform Begin\n" + e),
                        v = t.ViewPort.viewPorts[0],
                        c = new t.Element.rect;
                    return c.attributes.x = new t.Property("x", -t.MAX_VIRTUAL_PIXELS / 3), c.attributes.y = new t.Property("y", -t.MAX_VIRTUAL_PIXELS / 3), c.attributes.width = new t.Property("width", t.MAX_VIRTUAL_PIXELS), c.attributes.height = new t.Property("height", t.MAX_VIRTUAL_PIXELS), y = new t.Element.g, y.attributes.transform = new t.Property("transform", this.attribute("gradientTransform").value), y.children = [c], u = new t.Element.svg, u.attributes.x = new t.Property("x", 0), u.attributes.y = new t.Property("y", 0), u.attributes.width = new t.Property("width", v.width), u.attributes.height = new t.Property("height", v.height), u.children = [y], s = t.opts.cbGetWorkPad(v.width, v.height), l = s.getContext("2d"), l.fillStyle = h, p = t.opts.cbGetOSS2DCTX(l).logComment(o + "\ntempSvg.render Begin\n" + o).fnPatternStart(s.id, s.width, s.height), u.render(l), p.fnPatternEnd(), l.fillStyle = null, s = p.createPattern(s, "no-repeat"), p.logComment(o + "\ntempSvg.render End\n" + o).logComment(e + "\nGradientTransform End\n" + e), p = tt = h = y = u = l = v = c = null, s
                }
                return h[f] += ";\n", h
            }
        }, t.Element.GradientBase.prototype = new t.Element.ElementBase, t.Element.linearGradient = function (n) {
            this.base = t.Element.GradientBase, this.base(n), this.getGradient = function (n, i) {
                var r = i.getBoundingBox(),
                    u = this.gradientUnits == "objectBoundingBox",
                    f = this.attribute("x1"),
                    e = this.attribute("x2"),
                    o = this.attribute("y1"),
                    s = this.attribute("y2"),
                    h, y;
                f.hasValue() || o.hasValue() || e.hasValue() || s.hasValue() || (this.attribute("x1", !0).value = 0, this.attribute("y1", !0).value = 0, this.attribute("x2", !0).value = 1, this.attribute("y2", !0).value = 0);
                var c = u ? r.x() + r.width() * f.numValue() : f.toPixels("x"),
                    l = u ? r.y() + r.height() * o.numValue() : o.toPixels("y"),
                    a = u ? r.x() + r.width() * e.numValue() : e.toPixels("x"),
                    v = u ? r.y() + r.height() * s.numValue() : s.toPixels("y");
                if (c == a && l == v) return null;
                h = t.opts.cbGetOSS2DCTX(n);
                try {
                    return h.createLinearGradient(c, l, a, v)
                } finally {
                    y = null, h = null
                }
            }
        }, t.Element.linearGradient.prototype = new t.Element.GradientBase, t.Element.radialGradient = function (n) {
            this.base = t.Element.GradientBase, this.base(n), this.getGradient = function (n, i) {
                var r = i.getBoundingBox(),
                    u = this.gradientUnits == "objectBoundingBox",
                    c, f, l;
                this.attribute("cx").hasValue() || (this.attribute("cx", !0).value = "50%"), this.attribute("cy").hasValue() || (this.attribute("cy", !0).value = "50%"), this.attribute("r").hasValue() || (this.attribute("r", !0).value = "50%");
                var e = u ? r.x() + r.width() * this.attribute("cx").numValue() : this.attribute("cx").toPixels("x"),
                    o = u ? r.y() + r.height() * this.attribute("cy").numValue() : this.attribute("cy").toPixels("y"),
                    s = e,
                    h = o;
                this.attribute("fx").hasValue() && (s = u ? r.x() + r.width() * this.attribute("fx").numValue() : this.attribute("fx").toPixels("x")), this.attribute("fy").hasValue() && (h = u ? r.y() + r.height() * this.attribute("fy").numValue() : this.attribute("fy").toPixels("y")), c = u ? (r.width() + r.height()) / 2 * this.attribute("r").numValue() : this.attribute("r").toPixels(), f = t.opts.cbGetOSS2DCTX(n);
                try {
                    return f.createRadialGradient(s, h, 0, e, o, c)
                } finally {
                    l = null, f = null
                }
            }
        }, t.Element.radialGradient.prototype = new t.Element.GradientBase, t.Element.stop = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.offset = this.attribute("offset").numValue(), this.offset < 0 ? this.offset = 0 : this.offset > 1 && (this.offset = 1);
            var i = this.style("stop-color");
            this.style("stop-opacity").hasValue() && (i = i.addOpacity(this.style("stop-opacity").value)), this.color = i.value
        }, t.Element.stop.prototype = new t.Element.ElementBase, t.Element.AnimateBase = function (n) {
            this.base = t.Element.ElementBase, this.base(n), t.Animations.push(this), this.duration = 0, this.begin = this.attribute("begin").toMilliseconds(), this.maxDuration = this.begin + this.attribute("dur").toMilliseconds(), this.getProperty = function () {
                var t = this.attribute("attributeType").value,
                    n = this.attribute("attributeName").value;
                return t == "CSS" ? this.parent.style(n, !0) : this.parent.attribute(n, !0)
            }, this.initialValue = null, this.initialUnits = "", this.removed = !1, this.calcValue = function () {
                return ""
            }, this.update = function (n) {
                var i, t, r;
                if (this.initialValue == null && (this.initialValue = this.getProperty().value, this.initialUnits = this.getProperty().getUnits()), this.duration > this.maxDuration)
                    if (this.attribute("repeatCount").value == "indefinite" || this.attribute("repeatDur").value == "indefinite") this.duration = 0;
                    else return this.attribute("fill").valueOrDefault("remove") != "remove" || this.removed ? !1 : (this.removed = !0, this.getProperty().value = this.initialValue, !0);
                return this.duration = this.duration + n, i = !1, this.begin < this.duration && (t = this.calcValue(), this.attribute("type").hasValue() && (r = this.attribute("type").value, t = r + "(" + t + ")"), this.getProperty().value = t, i = !0), i
            }, this.from = this.attribute("from"), this.to = this.attribute("to"), this.values = this.attribute("values"), this.values.hasValue() && (this.values.value = this.values.value.split(";")), this.progress = function () {
                var n = {
                    progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
                };
                if (this.values.hasValue()) {
                    var i = n.progress * (this.values.value.length - 1),
                        r = Math.floor(i),
                        u = Math.ceil(i);
                    n.from = new t.Property("from", parseFloat(this.values.value[r])), n.to = new t.Property("to", parseFloat(this.values.value[u])), n.progress = (i - r) / (u - r)
                } else n.from = this.from, n.to = this.to;
                return n
            }
        }, t.Element.AnimateBase.prototype = new t.Element.ElementBase, t.Element.animate = function (n) {
            this.base = t.Element.AnimateBase, this.base(n), this.calcValue = function () {
                var n = this.progress(),
                    t = n.from.numValue() + (n.to.numValue() - n.from.numValue()) * n.progress;
                return t + this.initialUnits
            }
        }, t.Element.animate.prototype = new t.Element.AnimateBase, t.Element.animateColor = function (n) {
            this.base = t.Element.AnimateBase, this.base(n), this.calcValue = function () {
                var t = this.progress(),
                    n = new s(t.from.value),
                    i = new s(t.to.value);
                if (n.ok && i.ok) {
                    var r = n.r + (i.r - n.r) * t.progress,
                        u = n.g + (i.g - n.g) * t.progress,
                        f = n.b + (i.b - n.b) * t.progress;
                    return "rgb(" + parseInt(r, 10) + "," + parseInt(u, 10) + "," + parseInt(f, 10) + ")"
                }
                return this.attribute("from").value
            }
        }, t.Element.animateColor.prototype = new t.Element.AnimateBase, t.Element.animateTransform = function (n) {
            this.base = t.Element.AnimateBase, this.base(n), this.calcValue = function () {
                for (var i = this.progress(), r = t.ToNumberArray(i.from.value), f = t.ToNumberArray(i.to.value), u = "", n = 0; n < r.length; n++) u += r[n] + (f[n] - r[n]) * i.progress + " ";
                return u
            }
        }, t.Element.animateTransform.prototype = new t.Element.animate, t.Element.font = function (n) {
            var r, i;
            for (this.base = t.Element.ElementBase, this.base(n), this.horizAdvX = this.attribute("horiz-adv-x").numValue(), this.isRTL = !1, this.isArabic = !1, this.fontFace = null, this.missingGlyph = null, this.glyphs = [], r = 0; r < this.children.length; r++) i = this.children[r], i.type == "font-face" ? (this.fontFace = i, i.style("font-family").hasValue() && (t.Definitions[i.style("font-family").value] = this)) : i.type == "missing-glyph" ? this.missingGlyph = i : i.type == "glyph" && (i.arabicForm != "" ? (this.isRTL = !0, this.isArabic = !0, typeof this.glyphs[i.unicode] == "undefined" && (this.glyphs[i.unicode] = []), this.glyphs[i.unicode][i.arabicForm] = i) : this.glyphs[i.unicode] = i)
        }, t.Element.font.prototype = new t.Element.ElementBase, t.Element.fontface = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.ascent = this.attribute("ascent").value, this.descent = this.attribute("descent").value, this.unitsPerEm = this.attribute("units-per-em").numValue()
        }, t.Element.fontface.prototype = new t.Element.ElementBase, t.Element.missingglyph = function (n) {
            this.base = t.Element.path, this.base(n), this.horizAdvX = 0
        }, t.Element.missingglyph.prototype = new t.Element.path, t.Element.glyph = function (n) {
            this.base = t.Element.path, this.base(n), this.horizAdvX = this.attribute("horiz-adv-x").numValue(), this.unicode = this.attribute("unicode").value, this.arabicForm = this.attribute("arabic-form").value
        }, t.Element.glyph.prototype = new t.Element.path, t.Element.text = function (n) {
            this.captureTextNodes = !0, this.base = t.Element.RenderedElementBase, this.base(n), this.baseSetContext = this.setContext, this.setContext = function (n) {
                this.baseSetContext(n), this.style("dominant-baseline").hasValue() && (n.textBaseline = this.style("dominant-baseline").value), this.style("alignment-baseline").hasValue() && (n.textBaseline = this.style("alignment-baseline").value)
            }, this.getBoundingBox = function () {
                return new t.BoundingBox(this.attribute("x").toPixels("x"), this.attribute("y").toPixels("y"), 0, 0)
            }, this.renderChildren = function (n) {
                this.textAnchor = this.style("text-anchor").valueOrDefault("start"), this.x = this.attribute("x").toPixels("x"), this.y = this.attribute("y").toPixels("y");
                for (var t = 0; t < this.children.length; t++) this.renderChild(n, this, t)
            }, this.renderChild = function (n, t, i) {
                var r = t.children[i],
                    e, u, f, o, i;
                if (r.attribute("x").hasValue() ? r.x = r.attribute("x").toPixels("x") : (this.attribute("dx").hasValue() && (this.x += this.attribute("dx").toPixels("x")), r.attribute("dx").hasValue() && (this.x += r.attribute("dx").toPixels("x")), r.x = this.x), e = typeof (r.measureText == "undefined") ? 0 : r.measureText(n), this.textAnchor != "start" && (i == 0 || r.attribute("x").hasValue())) {
                    for (u = e, f = i + 1; f < this.children.length; f++) {
                        if (o = this.children[f], o.attribute("x").hasValue()) break;
                        u += o.measureText(n)
                    }
                    r.x -= this.textAnchor == "end" ? u : u / 2
                }
                for (this.x = r.x + e, r.attribute("y").hasValue() ? r.y = r.attribute("y").toPixels("y") : (this.attribute("dy").hasValue() && (this.y += this.attribute("dy").toPixels("y")), r.attribute("dy").hasValue() && (this.y += r.attribute("dy").toPixels("y")), r.y = this.y), this.y = r.y, r.render(n), i = 0; i < r.children.length; i++) this.renderChild(n, r, i)
            }
        }, t.Element.text.prototype = new t.Element.RenderedElementBase, t.Element.TextElementBase = function (n) {
            this.base = t.Element.RenderedElementBase, this.base(n), this.getGlyph = function (n, t, i) {
                var u = t[i],
                    r = null,
                    f;
                return n.isArabic ? (f = "isolated", (i == 0 || t[i - 1] == " ") && i < t.length - 2 && t[i + 1] != " " && (f = "terminal"), i > 0 && t[i - 1] != " " && i < t.length - 2 && t[i + 1] != " " && (f = "medial"), i > 0 && t[i - 1] != " " && (i == t.length - 1 || t[i + 1] == " ") && (f = "initial"), typeof n.glyphs[u] != "undefined" && (r = n.glyphs[u][f], r == null && n.glyphs[u].type == "glyph" && (r = n.glyphs[u]))) : r = n.glyphs[u], r == null && (r = n.missingGlyph), r
            }, this.renderChildren = function (n) {
                var i = this.parent.style("font-family").getDefinition(),
                    o, r, c, u, a, s, f;
                if (i != null) {
                    var h = this.parent.style("font-size").numValueOrDefault(t.Font.Parse(t.ctx.font).fontSize),
                        l = this.parent.style("font-style").valueOrDefault(t.Font.Parse(t.ctx.font).fontStyle),
                        e = this.getText();
                    for (i.isRTL && (e = e.split("").reverse().join("")), o = t.ToNumberArray(this.parent.attribute("dx").value), r = 0; r < e.length; r++) c = this.getGlyph(i, e, r), u = h / i.fontFace.unitsPerEm, n.translate(this.x, this.y), n.scale(u, -u), a = n.lineWidth, n.lineWidth = n.lineWidth * i.fontFace.unitsPerEm / h, l == "italic" && n.transform(1, 0, .4, 1, 0, 0), c.render(n), l == "italic" && n.transform(1, 0, -.4, 1, 0, 0), n.lineWidth = a, n.scale(1 / u, -1 / u), n.translate(-this.x, -this.y), this.x += h * (c.horizAdvX || i.horizAdvX) / i.fontFace.unitsPerEm, typeof o[r] == "undefined" || isNaN(o[r]) || (this.x += o[r]);
                    return
                }
                s = t.compressSpaces(this.getText()), s.length && (f = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.TextElementBase.renderChildren start"), n.fillStyle != "" && f.fillText(s, this.x, this.y), n.strokeStyle != "" && f.strokeText(s, this.x, this.y), f.logComment("svg.Element.TextElementBase.renderChildren end"), f = null)
            }, this.getText = function () {}, this.measureText = function (n) {
                var r = this.parent.style("font-family").getDefinition(),
                    f, i, s, o, h;
                if (r != null) {
                    var c = this.parent.style("font-size").numValueOrDefault(t.Font.Parse(t.ctx.font).fontSize),
                        e = 0,
                        u = this.getText();
                    for (r.isRTL && (u = u.split("").reverse().join("")), f = t.ToNumberArray(this.parent.attribute("dx").value), i = 0; i < u.length; i++) s = this.getGlyph(r, u, i), e += (s.horizAdvX || r.horizAdvX) * c / r.fontFace.unitsPerEm, typeof f[i] == "undefined" || isNaN(f[i]) || (e += f[i]);
                    return e
                }
                return (o = t.compressSpaces(this.getText()), !n.measureText) ? o.length * 10 : (n.save(), this.setContext(n), h = n.measureText(o).width, n.restore(), h)
            }
        }, t.Element.TextElementBase.prototype = new t.Element.RenderedElementBase, t.Element.tspan = function (n) {
            this.captureTextNodes = !0, this.base = t.Element.TextElementBase, this.base(n), this.text = n.nodeValue || n.text || "", this.getText = function () {
                return this.text
            }
        }, t.Element.tspan.prototype = new t.Element.TextElementBase, t.Element.tref = function (n) {
            this.base = t.Element.TextElementBase, this.base(n), this.getText = function () {
                var n = this.getHrefAttribute().getDefinition();
                if (n != null) return n.children[0].getText()
            }
        }, t.Element.tref.prototype = new t.Element.TextElementBase, t.Element.a = function (n) {
            this.base = t.Element.TextElementBase, this.base(n), this.hasText = !0;
            for (var i = 0; i < n.childNodes.length; i++) n.childNodes[i].nodeType != 3 && (this.hasText = !1);
            this.text = this.hasText ? n.childNodes[0].nodeValue : "", this.getText = function () {
                return this.text
            }, this.baseRenderChildren = this.renderChildren, this.renderChildren = function (n) {
                var r, i;
                this.hasText ? (this.baseRenderChildren(n), r = new t.Property("fontSize", t.Font.Parse(t.ctx.font).fontSize), t.Mouse.checkBoundingBox(this, new t.BoundingBox(this.x, this.y - r.toPixels("y"), this.x + this.measureText(n), this.y))) : (i = new t.Element.g, i.children = this.children, i.parent = this, i.render(n))
            }, this.onclick = function () {
                window.open(this.getHrefAttribute().value)
            }, this.onmousemove = function () {
                t.ctx.canvas.style.cursor = "pointer"
            }
        }, t.Element.a.prototype = new t.Element.TextElementBase, t.Element.image = function (n) {
            var r, f, e, u;
            this.base = t.Element.RenderedElementBase, this.base(n), r = this.getHrefAttribute().value, r = r.toLowerCase(), t.Images.push(this), this.loaded = 0, f ? (this.img = f, f = null) : (e = r.match(/\.svg$/), e ? this.img = t.ajax(r) : (u = this, this.img = i.createElement("img"), this.img.onload = function () {
                u.loaded = !0
            }, this.img.onerror = function () {
                u.loaded = !0
            }, this.img.src = r)), this.img._index = t.Images.length - 1, this.renderChildren = function (n) {
                var f = this.attribute("x").toPixels("x"),
                    o = this.attribute("y").toPixels("y"),
                    r = this.attribute("width").toPixels("x"),
                    u = this.attribute("height").toPixels("y"),
                    i;
                r != 0 && u != 0 && (i = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.image.renderChildren start").save(), e ? n.drawSvg(this.img, f, o, r, u) : (i.translate(f, o), t.AspectRatio(n, this.attribute("preserveAspectRatio").value, r, this.img.width, u, this.img.height, 0, 0), i.drawImage(this.img, 0, 0)), i.restore().logComment("svg.Element.image.renderChildren end"), i = null)
            }, this.getBoundingBox = function () {
                var n = this.attribute("x").toPixels("x"),
                    i = this.attribute("y").toPixels("y"),
                    r = this.attribute("width").toPixels("x"),
                    u = this.attribute("height").toPixels("y");
                return new t.BoundingBox(n, i, n + r, i + u)
            }
        }, t.Element.image.prototype = new t.Element.RenderedElementBase, t.Element.g = function (n) {
            this.base = t.Element.RenderedElementBase, this.base(n), this.getBoundingBox = function () {
                for (var i = new t.BoundingBox, n = 0; n < this.children.length; n++) i.addBoundingBox(this.children[n].getBoundingBox());
                return i
            }
        }, t.Element.g.prototype = new t.Element.RenderedElementBase, t.Element.symbol = function (n) {
            this.base = t.Element.RenderedElementBase, this.base(n), this.baseSetContext = this.setContext, this.setContext = function (n) {
                if (this.baseSetContext(n), this.attribute("viewBox").hasValue()) {
                    var i = t.ToNumberArray(this.attribute("viewBox").value),
                        r = i[0],
                        u = i[1];
                    width = i[2], height = i[3], t.AspectRatio(n, this.attribute("preserveAspectRatio").value, this.attribute("width").toPixels("x"), width, this.attribute("height").toPixels("y"), height, r, u), t.ViewPort.SetCurrent(i[2], i[3])
                }
            }
        }, t.Element.symbol.prototype = new t.Element.RenderedElementBase, t.Element.style = function (n) {
            var h, i, c, l, s, r, nt, e, u, a, it;
            this.base = t.Element.ElementBase, this.base(n);
            for (var f = "", v = n.childNodes, rt = v.length, i = 0; i < rt; i++) f += v[i].nodeValue;
            for (v = null, f = f.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ""), f = t.compressSpaces(f), h = f.split("}"), i = 0; i < h.length; i++)
                if (t.trim(h[i]) != "") {
                    var k = h[i].split("{"),
                        d = k[0].split(","),
                        o = k[1].split(";");
                    for (c = 0; c < d.length; c++)
                        if (l = t.trim(d[c]), l != "") {
                            for (s = {}, r = 0; r < o.length; r++) {
                                var y = o[r].indexOf(":"),
                                    p = o[r].substr(0, y),
                                    g = o[r].substr(y + 1, o[r].length - y);
                                p != null && g != null && (s[t.trim(p)] = new t.Property(t.trim(p), t.trim(g)))
                            }
                            if (t.Styles[l] = s, l == "@font-face")
                                for (nt = s["font-family"].value.replace(/"/g, ""), e = s.src.value.split(","), u = 0; u < e.length; u++)
                                    if (e[u].indexOf('format("svg")') > 0) {
                                        var w = e[u].indexOf("url"),
                                            ut = e[u].indexOf(")", w),
                                            ft = e[u].substr(w + 5, ut - w - 6),
                                            tt = t.parseXml(t.ajax(ft)),
                                            b = tt.getElementsByTagName("font");
                                        for (a = 0; a < b.length; a++) it = t.CreateElement(b[a]), t.Definitions[nt] = it;
                                        tt = b = null
                                    }
                        }
                }
        }, t.Element.style.prototype = new t.Element.ElementBase, t.Element.use = function (n) {
            this.base = t.Element.RenderedElementBase, this.base(n), this.baseSetContext = this.setContext, this.setContext = function (n) {
                this.baseSetContext(n), this.attribute("x").hasValue() && n.translate(this.attribute("x").toPixels("x"), 0), this.attribute("y").hasValue() && n.translate(0, this.attribute("y").toPixels("y"))
            }, this.getDefinition = function () {
                var n = this.getHrefAttribute().getDefinition();
                return this.attribute("width").hasValue() && (n.attribute("width", !0).value = this.attribute("width").value), this.attribute("height").hasValue() && (n.attribute("height", !0).value = this.attribute("height").value), n
            }, this.path = function (n) {
                var t = this.getDefinition();
                t != null && t.path(n)
            }, this.getBoundingBox = function () {
                var n = this.getDefinition();
                if (n != null) return n.getBoundingBox()
            }, this.renderChildren = function (n) {
                var t = this.getDefinition(),
                    i;
                t != null && (i = t.parent, t.parent = null, t.render(n), t.parent = i)
            }
        }, t.Element.use.prototype = new t.Element.RenderedElementBase, t.Element.mask = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.apply = function (n, i) {
                var e = this.attribute("x").toPixels("x"),
                    o = this.attribute("y").toPixels("y"),
                    s = this.attribute("width").toPixels("x"),
                    h = this.attribute("height").toPixels("y"),
                    a = i.attribute("mask").value,
                    c, l;
                i.attribute("mask").value = "", c = t.opts.cbGetWorkPad(e + s, o + h), l = c.getContext("2d"), this.renderChildren(l);
                var r = t.opts.cbGetWorkPad(e + s, o + h),
                    u = r.getContext("2d"),
                    f = t.opts.cbGetOSS2DCTX(u).fnPatternStart(r.id, r.width, r.height);
                i.render(u), u.globalCompositeOperation = "destination-in", u.fillStyle = l.createPattern(c, "no-repeat"), u.fillRect(0, 0, e + s, o + h), f.fnPatternEnd(), f.fillStyle = f.createPattern(r, "no-repeat"), f.fillRect(0, 0, e + s, o + h), i.attribute("mask").value = a, f = null, r = c = l = u = null
            }, this.render = function () {}
        }, t.Element.mask.prototype = new t.Element.ElementBase, t.Element.clipPath = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.apply = function (n) {
                for (var r = t.opts.cbGetOSS2DCTX(n).logComment("svg.Element.clipPath.apply start"), i = 0; i < this.children.length; i++) this.children[i].path && (this.children[i].path(n), r.clip());
                r.logComment("svg.Element.clipPath.apply end"), r = null
            }, this.render = function () {}
        }, t.Element.clipPath.prototype = new t.Element.ElementBase, t.Element.filter = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.apply = function (n, i) {
                var a = t.opts.cbGetOSS2DCTX(n).logUnsupported("svg.Element.filter.apply is unsupported"),
                    o = i.getBoundingBox(),
                    v = Math.floor(o.x1),
                    y = Math.floor(o.y1),
                    s = Math.floor(o.width()),
                    h = Math.floor(o.height()),
                    p = i.style("filter").value,
                    r, u, l, c, e, f;
                for (i.style("filter").value = "", r = 0, u = 0, f = 0; f < this.children.length; f++) l = this.children[f].extraFilterDistance || 0, r = Math.max(r, l), u = Math.max(u, l);
                for (c = t.opts.cbGetWorkPad(s + 2 * r, h + 2 * u), e = c.getContext("2d"), e.translate(-v + r, -y + u), i.render(e), f = 0; f < this.children.length; f++) this.children[f].apply(e, 0, 0, s + 2 * r, h + 2 * u);
                a.drawImage(c, 0, 0, s + 2 * r, h + 2 * u, v - r, y - u, s + 2 * r, h + 2 * u), i.style("filter", !0).value = p, c = e = null, a = null
            }, this.render = function () {}
        }, t.Element.filter.prototype = new t.Element.ElementBase, t.Element.feMorphology = function (n) {
            this.base = t.Element.ElementBase, this.base(n), this.apply = function () {}
        }, t.Element.feMorphology.prototype = new t.Element.ElementBase, t.Element.feColorMatrix = function (n) {
            function i(n, t, i, r, u, f) {
                return n[i * r * 4 + t * 4 + f]
            }

            function r(n, t, i, r, u, f, e) {
                n[i * r * 4 + t * 4 + f] = e
            }
            this.base = t.Element.ElementBase, this.base(n), this.apply = function (n, u, f, e, o) {
                var y = t.opts.cbGetOSS2DCTX(n).logUnsupported("svg.Element.feColorMatrix.apply is unsupported"),
                    c, u, f, l, a, v, h, s;
                for (y = null, c = n.getImageData(0, 0, e, o), s = c.data, f = 0; f < o; f++)
                    for (u = 0; u < e; u++) l = i(s, u, f, e, o, 0), a = i(s, u, f, e, o, 1), v = i(s, u, f, e, o, 2), h = (l + a + v) / 3, r(s, u, f, e, o, 0, h), r(s, u, f, e, o, 1, h), r(s, u, f, e, o, 2, h);
                s = null, n.clearRect(0, 0, e, o), n.putImageData(c, 0, 0)
            }
        }, t.Element.feColorMatrix.prototype = new t.Element.ElementBase, t.Element.feGaussianBlur = function (n) {
            function r(n, t, i, r) {
                var f = n.getImageData(0, 0, t, i),
                    u = make_fgauss(r);
                u = normalize(u), tmp = [], convolve_even(f.data, tmp, u, t, i), convolve_even(tmp, f.data, u, i, t), n.clearRect(0, 0, t, i), n.putImageData(f, 0, 0)
            }
            this.base = t.Element.ElementBase, this.base(n), this.blurRadius = Math.floor(this.attribute("stdDeviation").numValue()), this.extraFilterDistance = this.blurRadius, this.apply = function (n, r, u, f, e) {
                if (typeof stackBlurCanvasRGBA == "undefined") {
                    console.log("ERROR: StackBlur.js must be included for blur to work");
                    return
                }
                n.canvas.id = t.UniqueId(), n.canvas.style.display = "none", i.body.appendChild(n.canvas), stackBlurCanvasRGBA(n.canvas.id, r, u, f, e, this.blurRadius), i.body.removeChild(n.canvas)
            }, this.apply = function (n, i, u, f, e) {
                var o = t.opts.cbGetOSS2DCTX(n).logUnsupported("svg.Element.feGaussianBlur.apply blur is unsupported");
                r(n, f, e, this.attribute("stdDeviation").numValue())
            }
        }, t.Element.feGaussianBlur.prototype = new t.Element.ElementBase, t.Element.title = function () {}, t.Element.title.prototype = new t.Element.ElementBase, t.Element.desc = function () {}, t.Element.desc.prototype = new t.Element.ElementBase, t.Element.MISSING = function () {}, t.Element.MISSING.prototype = new t.Element.ElementBase, t.CreateElement = function (n) {
            var i = n.nodeName.replace(/^[^:]+:/, ""),
                r;
            return i = i.replace(/\-/g, ""), r = null, i == "canvg" && (i = "svg"), r = typeof t.Element[i] != "undefined" ? new t.Element[i](n) : new t.Element.MISSING(n), r.type = n.nodeName, r
        }, t.load = function (n, i) {
            t.loadXml(n, t.ajax(i))
        }, t.loadXml = function (n, i) {
            t.loadXmlDoc(n, t.parseXml(i))
        }, t.loadXmlDoc = function (i, r) {
            var e, u;
            t.init(i), e = function (n) {
                for (var t = i.canvas; t;) n.x -= t.offsetLeft, n.y -= t.offsetTop, t = t.offsetParent;
                return window.scrollX && (n.x += window.scrollX), window.scrollY && (n.y += window.scrollY), n
            }, t.opts.ignoreMouse != !0 && (i.canvas.onclick = function (n) {
                var i = e(new t.Point(n != null ? n.clientX : event.clientX, n != null ? n.clientY : event.clientY));
                t.Mouse.onclick(i.x, i.y)
            }, i.canvas.onmousemove = function (n) {
                var i = e(new t.Point(n != null ? n.clientX : event.clientX, n != null ? n.clientY : event.clientY));
                t.Mouse.onmousemove(i.x, i.y)
            }), u = t.CreateElement(r.documentElement), u.root = !0;
            var o = function () {
                var r = t.opts,
                    f = i.canvas,
                    s, e, o, c;
                if (t.ViewPort.Clear(), f.parentNode && (s = n(f.parentNode), t.ViewPort.SetCurrent(s.width(), s.height()), s = null), r.ignoreDimensions != !0 && (u.style("width").hasValue() && (f.width = u.style("width").toPixels("x"), f.style.width = f.width + "px"), u.style("height").hasValue() && (f.height = u.style("height").toPixels("y"), f.style.height = f.height + "px")), r.ignoreDimensions == !0 && u.style("width").hasValue() && u.style("height").hasValue() ? (e = u.style("width").toPixels("x"), o = u.style("height").toPixels("y")) : (c = n(f), e = c.width(), o = c.height()), t.ViewPort.SetCurrent(e, o), r.offsetX != null && (u.attribute("x", !0).value = r.offsetX), r.offsetY != null && (u.attribute("y", !0).value = r.offsetY), r.scaleWidth != null && r.scaleHeight != null) {
                    var l = 1,
                        a = 1,
                        h = t.ToNumberArray(u.attribute("viewBox").value);
                    u.attribute("width").hasValue() ? l = u.attribute("width").toPixels("x") / r.scaleWidth : isNaN(h[2]) || (l = h[2] / r.scaleWidth), u.attribute("height").hasValue() ? a = u.attribute("height").toPixels("y") / r.scaleHeight : isNaN(h[3]) || (a = h[3] / r.scaleHeight), u.attribute("width", !0).value = r.scaleWidth, u.attribute("height", !0).value = r.scaleHeight, u.attribute("viewBox", !0).value = "0 0 " + e * l + " " + o * a, u.attribute("preserveAspectRatio", !0).value = "none"
                }
                r.ignoreClear != !0 && i.clearRect(0, 0, e, o), u.render(i)
            }, s, h = this,
                f = t.opts;
            (function c() {
                function u(t) {
                    var i, f, u;
                    if (n.isArray(t))
                        for (f = t.length, i = 0; i < f; i++) u = t[i], typeof u != "function" && n.error("runFNCallbacks: Requires array of callback functions"), u.call(h, r)
                }
                if (s = !t.ImagesLoaded(), s) {
                    setTimeout(c, 5);
                    return
                }
                var r = f.cbGetOSS2DCTX(i);
                u(f.onInitDraw), r.fnRender(!0, "", t.opts.fnId), o(), u(f.onExitRender), r.fnRender(0), u(f.onDrawComplete), r.destroy(), r = null, t.drawCanvas = function () {
                    o()
                }
            })(), h = null
        }, t.stop = function () {
            t.intervalID && clearInterval(t.intervalID)
        }, t.Mouse = new function () {
            this.events = [], this.hasEvents = function () {
                return this.events.length != 0
            }, this.onclick = function (n, t) {
                this.events.push({
                    type: "onclick",
                    x: n,
                    y: t,
                    run: function (n) {
                        n.onclick && n.onclick()
                    }
                })
            }, this.onmousemove = function (n, t) {
                this.events.push({
                    type: "onmousemove",
                    x: n,
                    y: t,
                    run: function (n) {
                        n.onmousemove && n.onmousemove()
                    }
                })
            }, this.eventElements = [], this.checkPath = function (n, t) {
                for (var r, i = 0; i < this.events.length; i++) r = this.events[i], t.isPointInPath && t.isPointInPath(r.x, r.y) && (this.eventElements[i] = n)
            }, this.checkBoundingBox = function (n, t) {
                for (var r, i = 0; i < this.events.length; i++) r = this.events[i], t.isPointInBox(r.x, r.y) && (this.eventElements[i] = n)
            }, this.runEvents = function () {
                var n, r, i;
                for (t.ctx.canvas.style.cursor = "", n = 0; n < this.events.length; n++)
                    for (r = this.events[n], i = this.eventElements[n]; i;) r.run(i), i = i.parent;
                this.events = [], this.eventElements = []
            }
        }, t
    }

    function h() {}

    function l() {
        this._defaults = {
            xml: null,
            onError: function (n) {
                alert("SVG Parse Error:" + n.name + "\nError:" + n.message)
            },
            watermark: {
                text: ""
            },
            canvg: {
                onInitDraw: [],
                onDrawComplete: [],
                onExitRender: []
            }
        }
    }

    function y(t, i) {
        return t == "option" && (i.length == 0 || i.length == 1 && typeof i[0] == "string") ? !0 : n.inArray(t, a) > -1
    }
    var a, r;
    EVTCUSTOM_DESTROYED = "destroyed", n.event.special.load = {
        add: function (t) {
            if (this.nodeType === 1 && this.tagName.toLowerCase() === "img" && this.src !== "")
                if (this.complete || this.readyState == "complete" || this.readyState === 4) t.handler.apply(this);
                else if (this.readyState === "uninitialized" && this.src.indexOf("data:") === 0) n(this).trigger("error");
            else n(this).on("load", t.handler)
        }
    }, "use strict";
    var u = "OSS2DCTX",
        f = "osscmd",
        c = "ossCanvg",
        e = "===============================",
        o = "-------------------------------";
    t[u] = function (i, r) {
        if (!(this instanceof OSS2DCTX)) {
            var f = n.data(i.canvas, u);
            return f || (f = new OSS2DCTX(i), n.data(i.canvas, u, f)), f
        }
        this.ctx = i, this.PLUGINNAME = u, t[u].prototype.arc || t[u].setup.call(this, r)
    }, t[u].setup = function (i) {
        "use strict";
        var l = [],
            s = {
                cmd: "",
                args: null,
                tot: 0
            }, y = [],
            p = [],
            b = !1,
            k = !0,
            d, ut, ft, et = "",
            u = "",
            e = "",
            g = "",
            w = 0,
            h = "ctx",
            c = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "drawImage", "fill", "fillRect", "fillText", "lineTo", "moveTo", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setTransform", "stroke", "strokeRect", "strokeText", "transform", "translate"],
            a = ["createPattern", "createRadialGradient", "createLinearGradient", "drawFocusRing", "isPointInPath", "measureText", "createImageData", "getImageData", "putImageData"],
            v = ["canvas", "fillStyle", "font", "globalAlpha", "globalCompositeOperation", "lineCap", "lineJoin", "lineWidth", "miterLimit", "shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor", "strokeStyle", "textAlign", "textBaseline"],
            r, nt = function (n) {
                s.tot++, this.logUnsupported(n + " #" + s.tot), e += "/* ERROR:" + n + " */\n"
            }, ot = function (t, i) {
                var f = n.isArray(i),
                    u, r;
                if (s.cmd == t)
                    if (t === "restore") s.cmd === "save" && nt("Empty save/restore block");
                    else if (u = s.args, typeof i == typeof u && f) {
                    if (r = u.length, i.length == r) {
                        while (r--)
                            if (u[r] != i[r]) break
                    } else r = u === i ? 0 : -1;
                    r < 0 && nt("duplicate cmd:" + t)
                }
                s.args = f ? i.slice() : i, s.cmd = t
            }, o, st, tt, it, rt;
        for (e = et, OSS2DCTX.prototype.options = function (t) {
            var i = {
                analyze: 0,
                verbose: 0,
                roundup: 2
            };
            return t && n.extend(i, t), r = i.roundup > 0 ? Math.pow(10, i.roundup) : null, b = i.verbose, d = i.analyze, u = b ? "\n" : "", this
        }, OSS2DCTX.prototype.CtxName = function () {
            return h
        }, OSS2DCTX.prototype.destroy = function () {
            var t;
            return this.ctx.canvas && (t = n.data(this.ctx.canvas), t || (t[this.PLUGINNAME].ctx = null), t = null), n.removeData(this.PLUGINNAME), l.length = 0, y.length = 0, p.length = 0, this
        }, OSS2DCTX.prototype.getCntrs = function (n) {
            return n ? [{
                title: "Properties",
                names: v
            }, {
                title: "Getter Methods",
                names: a
            }, {
                title: "Methods",
                names: c
            }] : p.concat(y, l)
        }, OSS2DCTX.prototype.clearCntrs = function () {
            for (var n = v.length; n--;) p[n] = 0;
            for (n = a.length; n--;) y[n] = 0;
            for (n = c.length; n--;) l[n] = 0;
            s.cmd = "", s.args = null, s.tot = 0
        }, OSS2DCTX.prototype.fnRender = function (n, t, i) {
            typeof t == "undefined" ? t = u : t += u;
            var r = this.ctx.canvas.svg.Images.length;
            //return n ? (i && i.length != 0 || (i = "Canvas"), this.fnId = "draw" + i, r && (t += "var arrImg=_svg.Images;" + u), e += t + "function " + this.fnId + "(){" + u + "var _gm,_pattern,_img;" + u) : (e += "_gm=_pattern=_img=null;}" + u + t, e += this.fnId + "();" + u, r && (e += "arrImg=null;" + u), n = l[c.indexOf("save")], r = l[c.indexOf("restore")], n !== r && nt.call(this, "Unbalanced save(" + n + ")/restore(" + r + ") blocks"), this.fnId = null), this
            return n ? (i && i.length != 0 || (i = "Canvas"), this.fnId = "draw" + i, r && (t += "var arrImg=_svg.Images;" + u), e += t + "function " + this.fnId + "(){" + u + "var _gm,_pattern,_img;" + u) : (e += "_gm=_pattern=_img=null;}" + u + t, e += this.fnId + "();" + u, r && (e += "arrImg=null;" + u), n = l[c.indexOf("save")], r = l[c.indexOf("restore")], false && nt.call(this, "Unbalanced save(" + n + ")/restore(" + r + ") blocks"), this.fnId = null), this
        }, OSS2DCTX.prototype.fnPatternStart = function (n, i, r) {
            return this.logComment("Define fnPatternStart--------"), e += "_img=function(){" + u + "var c=document.createElement('canvas');" + u, typeof t.FlashCanvas != "undefined" && (e += "window.FlashCanvas.initElement(c);" + u), e += "var " + h + "=c.getContext('2d');" + u + "c.width=" + i + ";c.height=" + r + ";" + u, this
        }, OSS2DCTX.prototype.fnPatternEnd = function () {
            return e += u + h + "=null;" + u + "return c;" + u + "};" + u, this.logComment("Define fnPatternEnd--------"), this
        }, OSS2DCTX.prototype.logMethod = function (n, t, i) {
            var r;
            if (k) {
                var o = "",
                    s = i.length,
                    c = s - 1,
                    l = n + h + "." + t + "(",
                    f;
                for (r = 0; r < s; r++) f = i[r], o += typeof f == "string" ? "'" + f + "'" : f, r < c && (o += ",");
                e += l + o + ");" + u, d && ot.call(this, t, i)
            }
            return this
        }, OSS2DCTX.prototype.logComment = function (n) {
            return b && k && (e += "/* " + n + " */" + u), this
        }, OSS2DCTX.prototype.logWrite = function (n) {
            return e += n + u, this
        }, OSS2DCTX.prototype.logUnsupported = function (n) {
            w++;
            var t = "U" + w + " " + n;
            return t += "\n", g += t, this
        }, OSS2DCTX.prototype.logProp = function (n, t) {
            if (k) {
                var i = h + "." + n + "=",
                    r;
                switch (typeof t) {
                case "string":
                    i += "'" + t + "'";
                    break;
                case "number":
                    i += t;
                    break;
                case "object":
                    if (typeof t[f] == "string") {
                        i += t[f], delete t[f];
                        break
                    }
                default:
                    return r = OSS.utils.toType(t), this.logUnsupported(i + " [" + r + "]"), this
                }
                e += i + ";" + u, d && ot.call(this, n, t)
            }
            return this
        }, OSS2DCTX.prototype.getLog = function (n) {
            var t;
            isNaN(n) && (n = -1);
            switch (n) {
            case 0:
                return {
                    cnt: w,
                    txt: g
                };
            default:
                return t = e, e = "", t
            }
        }, OSS2DCTX.prototype.clearLogs = function () {
            return e = et, g = "", w = 0, this.clearCntrs(), this
        }, o = 0, st = c.length; o < st; o++) tt = c[o], OSS2DCTX.prototype[tt] = function (n) {
            return function () {
                if (r && (n === "lineTo" || n === "bezierCurveTo" || n === "quadraticCurveTo" || n === "moveTo" || n === "translate" ? (arguments[0] = .5 + arguments[0] << 0, arguments[1] = .5 + arguments[1] << 0, (n === "bezierCurveTo" || n === "quadraticCurveTo") && (arguments[2] = .5 + arguments[2] << 0, arguments[3] = .5 + arguments[3] << 0, n === "bezierCurveTo" && (arguments[4] = .5 + arguments[4] << 0, arguments[5] = .5 + arguments[5] << 0))) : n === "save" || n === "restore" || (n === "strokeText" || n === "fillText" ? (arguments[1] = .5 + arguments[1] << 0, arguments[2] = .5 + arguments[2] << 0) : n === "scale" || n === "transform" || n === "arc" ? (arguments[0] = Math.floor(arguments[0] * r) / r, arguments[1] = Math.floor(arguments[1] * r) / r, n === "transform" && (arguments[2] = Math.floor(arguments[2] * r) / r, arguments[3] = Math.floor(arguments[3] * r) / r, arguments[4] = Math.floor(arguments[4] * r) / r, arguments[5] = Math.floor(arguments[5] * r) / r)) : n === "rotate" && (arguments[0] = Math.floor(arguments[0] * r) / r))), this.ctx[n].apply(this.ctx, arguments), l[c.indexOf(n)]++, n === "drawImage") {
                    var t = arguments[0]._index;
                    return e += h + ".drawImage(arrImg[" + t + "].img," + [].splice.call(arguments, 1, arguments.length).join(",") + ");" + u, this
                }
                return this.logMethod("", n, arguments)
            }
        }(tt);
        for (o = 0, ut = a.length; o < ut; o++) it = a[o], OSS2DCTX.prototype[it] = function (n) {
            return function () {
                var t, i;
                return r && (n === "createLinearGradient" || n === "createRadialGradient") && (arguments[0] = Math.floor(arguments[0] * r) / r, arguments[1] = Math.floor(arguments[1] * r) / r, arguments[2] = Math.floor(arguments[2] * r) / r, arguments[3] = Math.floor(arguments[3] * r) / r, n === "createRadialGradient" && (arguments[4] = Math.floor(arguments[4] * r) / r, arguments[5] = Math.floor(arguments[5] * r) / r)), i = this.ctx[n].apply(this.ctx, arguments), y[a.indexOf(n)]++, n === "createPattern" ? (e += "_pattern=" + h + '.createPattern(_img(),"' + arguments[1] + '");' + u, t = "_pattern") : (t = "_gm", this.logMethod(t + "=", n, arguments)), i[f] = t, i
            }
        }(it);
        for (o = 0, ft = v.length; o < ft; o++) rt = v[o], OSS2DCTX.prototype[rt] = function (n) {
            return function (t) {
                return r && n === "lineWidth" && (t = Math.floor(t * r) / r), this.ctx[n] = t, p[v.indexOf(n)]++, this.logProp(n, t), this
            }
        }(rt);
        this.options(i)
    }, t.canvg = function (t, r, u) {
        var f, e;
        t == null && r == null && u == null && n.error("Requires target & svg source"), typeof t == "string" && (t = i.getElementById(t)), f = v(), t.childNodes.length == 1 && t.childNodes[0].nodeName == "OBJECT" || (t.svg = f), f.opts = n.extend({
            server: "",
            ignoreMouse: !0,
            ignoreAnimation: !0,
            ignoreDimensions: !1,
            ignoreClear: !0
        }, u), u.cbGetWorkPad || n.error("Requires ossCanvg owner reference"), e = t.getContext("2d"), typeof r.documentElement != "undefined" ? f.loadXmlDoc.call(this, e, r) : r.substr(0, 1) == "<" ? f.loadXml.call(this, e, r) : f.load.call(this, e, r), r = t = e = f = null
    }, h.prototype = {
        key: "",
        type: "",
        obj: null
    }, n.extend(l.prototype, {
        DATA_CACHECANVAS: "cacheCanvas",
        DATA_CACHE2DCTX: "cache2DCTX",
        markerClassName: "hasOSSCanvg",
        propertyName: "ossCanvg",
        _disabledClass: "ossCanvg-disabled",
        fnGetWorkPad: function (n, r, u) {
            var l, s, f, o, e;
            try {
                return l = 0, o = n.length, !l && o ? f = n[o - 1].obj : (s = "workpad" + o, f = i.createElement("canvas"), f.setAttribute("id", s), typeof t.FlashCanvas != "undefined" && t.FlashCanvas.initElement(f), e = new h, e.key = s, e.obj = f, e.type = "canvas", n.push(e), e = null), f.width = r, f.height = u, f
            } finally {
                f = n = null
            }
        },
        fnGetOSS2DCTX: function (n, t, i) {
            for (var f = i.length, r = 0; r < f; r++)
                if (i[r].key == n) break;
            return r >= f && (oCacheItem = new h, oCacheItem.key = n, oCacheItem.type = u, oCacheItem.obj = new OSS2DCTX(t), r = i.push(oCacheItem) - 1), i[r].obj
        },
        fnSetupCanvgOpts: function (n, t) {
            var i, u = n;
            return i = u.options.canvg, i.fnId = t, i.cbGetWorkPad = function (n, t) {
                return r.fnGetWorkPad(u[r.DATA_CACHECANVAS], n, t)
            }, i.cbGetOSS2DCTX = function (n) {
                return r.fnGetOSS2DCTX(n.canvas.id, n, u[r.DATA_CACHE2DCTX])
            }, i
        },
        fnClearCache: function (n, t) {
            var r = n[t],
                u = r.length,
                i;
            if (u) {
                while (u--) i = r[u], i && (i.obj.destroy && i.obj.destroy(), i.obj = i.key = i.type = null), r[u] = null;
                r.length = 0, r = i = null
            }
        },
        fnWatermark: function (n, t) {
            t.length && n.strokeStyle("#003300").font("20px san-serif").textBaseline("bottom").strokeText(t, 10, 22).strokeStyle("#FF3300").fillText(t, 10, 22)
        },
        _initPlugin: function (i, r) {
            if (!i.hasClass(this.markerClassName)) {
                i.on(EVTCUSTOM_DESTROYED + "." + this.propertyName, function () {
                    this._destroyPlugin
                });
                var e = {
                    options: n.extend({}, this._defaults),
                    cacheCanvas: [],
                    cache2DCTX: []
                }, f = e.options.canvg,
                    u = r.canvg;
                u.onInitDraw && (f.onInitDraw.push(u.onInitDraw), delete u.onInitDraw), u.onDrawComplete && (f.onDrawComplete.unshift(u.onDrawComplete), delete u.onDrawComplete), u.onExitRender && (f.onExitRender.unshift(u.onExitRender), delete u.onExitRender), i.addClass(this.markerClassName).data(this.propertyName, e), typeof t.FlashCanvas != "undefined" && t.FlashCanvas.initElement(i[0]), this._optionPlugin(i, r)
            }
        },
        _optionPlugin: function (t, i, r) {
            var f = t.data(this.propertyName),
                u;
            if (!i || typeof i == "string" && r == null) return u = i, i = (f || {}).options, i && u ? i[u] : i;
            t.hasClass(this.markerClassName) && (i = i || {}, typeof i == "string" && (u = i, i = {}, i[u] = r), n.extend(!0, f.options, i))
        },
        _getOSS2DCTXPlugin: function (n) {
            var t = n.data(this.propertyName),
                i, u = n.attr("id"),
                r;
            try {
                return r = t[this.DATA_CACHE2DCTX], i = n[0].getContext("2d"), this.fnGetOSS2DCTX(u, i, r)
            } catch (f) {
                t.options.onError(f)
            } finally {
                i = t = r = null
            }
        },
        _buildPlugin: function (n, t) {
            var u, i, f;
            try {
                i = n.data(this.propertyName), f = i.internal || n[0], u = r.fnSetupCanvgOpts(i, t.fnId), canvg.call(this, f, t.xml, u)
            } catch (e) {
                i.options.onError(e)
            }
            u = i = f = null
        },
        _enablePlugin: function (n) {
            n.hasClass(this.markerClassName) && n.prop("disabled", !1).removeClass(this.propertyName + "-disabled")
        },
        _disablePlugin: function (n) {
            n.hasClass(this.markerClassName) && n.prop("disabled", !0).addClass(this.propertyName + "-disabled")
        },
        _destroyPlugin: function (t) {
            var i, r;
            t.hasClass(this.markerClassName) && (i = t.data(this.propertyName), this._resetPlugin(t), i.options.onError = null, r = i.internal || t[0], r.width = r.width, i.internal && (n(i.internal).remove(), i.internal = null), r = null, i[u] && (i[u].ctx = null), i = null, t.removeClass(this.markerClassName).removeData(this.propertyName).unbind("." + this.propertyName))
        },
        _resetPlugin: function (t) {
            var f = t.data(this.propertyName),
                i, o, r, u, e;
            if (f) {
                if (o = f.internal || t[0], i = o.svg, i) {
                    if (i.stop(), i.ViewPort.Clear(), r = i.opts, r.cbGetWorkPad = r.cbGetOSS2DCTX = null, r = i.Images, u = r.length, u) {
                        while (u--) e = r[u].img, e.onload = e.onabort = e.onerror = null, r[u].img = null;
                        r.length = 0
                    }
                    if (n.each(i.Definitions, function (n, t) {
                        t = null
                    }), delete i.Definitions, n.each(i.Styles, function (n, t) {
                        t = null
                    }), delete i.Styles, r = i.Animations, u = r.length, u) {
                        while (u--) r[u] = null;
                        r.length = 0
                    }
                    delete i.Animations, delete i.Images, delete i.Element, delete i.ViewPort.viewPorts, i.ctx._swf || (i.ctx = i.ctx.canvas = null), i.Font = i.opts = i.ViewPort = null, e = r = i = null, o.svg = null
                }
                this.fnClearCache(f, this.DATA_CACHECANVAS), this.fnClearCache(f, this.DATA_CACHE2DCTX), f = o = null
            }
        },
        _resizePlugin: function (t, i) {
            var r = t[0],
                u;
            try {
                typeof i == "undefined" ? (u = t.parent(), r.height = u.innerHeight(), r.width = u.innerWidth(), u = null) : (r.height = i.h, r.width = i.w), r.svg.drawCanvas(!0)
            } catch (f) {
                n.error(PLUGINNAME_DEPRECATEDOSSCANVG + ":resize: " + f.message)
            } finally {
                r = null
            }
        }
    }), a = ["getOSS2DCTX"], n.fn[c] = function (t) {
        var i = Array.prototype.slice.call(arguments, 1),
            u = "_" + t + "Plugin";
        return y(t, i) ? r[u].apply(r, [this].concat(i)) : this.each(function () {
            typeof t == "string" ? r[u] ? r[u].apply(r, [n(this)].concat(i)) : n.error(this.propertyName + ":Unknown method: " + t) : r._initPlugin(n(this), t || {})
        })
    }, r = n.ossCanvg = new l
})(jQuery, window, window.document), typeof CanvasRenderingContext2D != "undefined" && (CanvasRenderingContext2D.prototype.drawSvg = function (n, t, i, r, u) {
    canvg(this.canvas, n, {
        offsetX: t,
        offsetY: i,
        scaleWidth: r,
        scaleHeight: u
    })
});
